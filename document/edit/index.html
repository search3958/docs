<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TinyMCE フルスクリーンエディタ</title>

<link href="https://fonts.googleapis.com/css2?family=M+PLUS+2:wght@400;700&display=swap" rel="stylesheet">

<script src="https://cdn.tiny.cloud/1/63grb1v3dxrozqsl94n6376c15nieburu1zbpwrvf52a8rhd/tinymce/7/tinymce.min.js" referrerpolicy="origin"></script>
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>


<script>
if ("paintWorklet" in CSS) {
  const workletCode = `
    const drawSquircle=(ctx,geom,radii,smooth,lineWidth,color)=>{const defaultFill=color;const lineWidthOffset=lineWidth/2;ctx.beginPath();ctx.lineTo(radii[0],lineWidthOffset);ctx.lineTo(geom.width-radii[1],lineWidthOffset);ctx.bezierCurveTo(geom.width-radii[1]/smooth,lineWidthOffset,geom.width-lineWidthOffset,radii[1]/smooth,geom.width-lineWidthOffset,radii[1]);ctx.lineTo(geom.width-lineWidthOffset,geom.height-radii[2]);ctx.bezierCurveTo(geom.width-lineWidthOffset,geom.height-radii[2]/smooth,geom.width-radii[2]/smooth,geom.height-lineWidthOffset,geom.width-radii[2],geom.height-lineWidthOffset);ctx.lineTo(radii[3],geom.height-lineWidthOffset);ctx.bezierCurveTo(radii[3]/smooth,geom.height-lineWidthOffset,lineWidthOffset,geom.height-radii[3]/smooth,lineWidthOffset,geom.height-radii[3]);ctx.lineTo(lineWidthOffset,radii[0]);ctx.bezierCurveTo(lineWidthOffset,radii[0]/smooth,radii[0]/smooth,lineWidthOffset,radii[0],lineWidthOffset);ctx.closePath();if(lineWidth){ctx.strokeStyle=defaultFill;ctx.lineWidth=lineWidth;ctx.stroke()}else{ctx.fillStyle=defaultFill;ctx.fill()}};class SquircleClass{static get contextOptions(){return{alpha:true}}static get inputProperties(){return["--squircle-radius","--squircle-radius-top-left","--squircle-radius-top-right","--squircle-radius-bottom-right","--squircle-radius-bottom-left","--squircle-smooth","--squircle-outline","--squircle-fill"]}paint(ctx,geom,properties){const smoothRatio=10;const distanceRatio=1.8;const squircleSmooth=parseFloat(properties.get("--squircle-smooth")*smoothRatio);const individualRadiiProps=SquircleClass.inputProperties.slice(1,5);let squircleRadii=individualRadiiProps.map(prop=>{const value=properties.get(prop);return value?parseInt(value,10)*distanceRatio:NaN});let shorthand_R;if(squircleRadii.some(isNaN)){const radiusRegex=/([0-9]+[a-z%]*)/g;const radius_shorthand=properties.get("--squircle-radius").toString();const matches=radius_shorthand.match(radiusRegex);if(matches){shorthand_R=matches.map(val=>parseInt(val,10)*distanceRatio);while(shorthand_R.length<4){if(shorthand_R.length===1){shorthand_R.push(shorthand_R[0])}else if(shorthand_R.length===2){shorthand_R=[shorthand_R[0],shorthand_R[1],shorthand_R[0],shorthand_R[1]]}else if(shorthand_R.length===3){shorthand_R=[shorthand_R[0],shorthand_R[1],shorthand_R[2],shorthand_R[1]]}}}else{const defaultRadius=squircleRadii.every(isNaN)?8*distanceRatio:0;shorthand_R=[defaultRadius,defaultRadius,defaultRadius,defaultRadius]}}squircleRadii=squircleRadii.map((val,i)=>isNaN(val)?shorthand_R[i]:val);const squrcleOutline=parseFloat(properties.get("--squircle-outline"),10);const squrcleColor=properties.get("--squircle-fill").toString();const isSmooth=()=>{if(typeof properties.get("--squircle-smooth")[0]!=="undefined"){if(squircleSmooth===0){return 1}return squircleSmooth}else{return 10}};const isOutline=()=>{if(squrcleOutline){return squrcleOutline}else{return 0}};const isColor=()=>{if(squrcleColor){return squrcleColor}else{return"#f45"}};const maxRadius=Math.max(...squircleRadii);if(maxRadius<geom.width/2&&maxRadius<geom.height/2){drawSquircle(ctx,geom,squircleRadii,isSmooth(),isOutline(),isColor())}else{const minRadius=Math.min(geom.width/2,geom.height/2);drawSquircle(ctx,geom,squircleRadii.map(()=>minRadius),isSmooth(),isOutline(),isColor())}}}if(typeof registerPaint!=="undefined"){registerPaint("squircle",SquircleClass)}
  `;
  const blob = new Blob([workletCode], { type: 'application/javascript' });
  const blobURL = URL.createObjectURL(blob);
  CSS.paintWorklet.addModule(blobURL);
}
</script>

<style>
.tox .tox-edit-area::before{
    border: none !important;
}
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
  background: #f0f0f0;
}
#editor {
  height: 100vh;
  width: 100vw;
}
/* ✨ メニューバー全体に M PLUS 2 フォントを適用 */
.tox-menubar, .tox-toolbar {
    font-family: 'M PLUS 2', sans-serif !important;
}

/* ✨ カスタムドキュメントリンクのスタイル調整 (メニューボタンに揃える) */
.tox-mbtn#documentlink {
    font-weight: bold;
    color: #333;
    /* その他のスタイルはTinyMCEのデフォルトに依存 */
}
.tox .tox-tbtn{
    background: #eeeeee!important;
    padding: 20px!important;
    margin:0px!important;
    transition:all 0.2s ease;
    }
.tox .tox-tbtn--active, .tox .tox-tbtn--enabled, .tox .tox-tbtn--enabled:focus, .tox .tox-tbtn--enabled:hover{
    background:#006ce7!important;
    border-radius: 20px !important;
}
.tox .tox-tbtn--active svg, .tox .tox-tbtn--enabled svg, .tox .tox-tbtn--enabled:focus svg, .tox .tox-tbtn--enabled:hover svg{
    fill:#ffffff!important;
    transition:all 0.2s ease;
}
.tox-toolbar__group{
    padding:0px !important;
    border-radius: 100px !important;
    overflow:hidden;
    gap:2px;
}
.tox-toolbar__primary {
    gap: 8px;
}
.tox-toolbar__primary{
    background-image: unset!important;
    padding:4px 16px !important;
}
.tox .tox-menu{
    border:none !important;
    --squircle-radius: 13px;
    --squircle-smooth: 0.6;
    background: paint(squircle) !important;
    --squircle-fill: #fff;
    filter:drop-shadow(0 4px 16px #0005);
    box-shadow:none!important;
}
.tox .tox-collection--list .tox-collection__item--active:not(.tox-collection__item--state-disabled){
    mask-image: paint(squircle);
    --squircle-radius: 12px;
    --squircle-smooth: 0.4;
}
.tox .tox-mbtn{
    mask-image: paint(squircle);
    --squircle-radius: 12px;
    --squircle-smooth: 0.4;
    }
    .tox-menubar {
        padding: 10px !important;;
    padding-left: 59px !important;
}
.tox .tox-mbtn__select-label{
    margin: 0px !important;
}
.tox .tox-mbtn{
    padding: 14px !important;
}
.headicon{
    position:fixed;
    top:0px;
    left:0px;
    z-index:3;
}
.tox-promotion{
    display: none !important;;
}
button.tox-mbtn.tox-mbtn--select {
    width: fit-content !important;
}
</style>
</head>
<body>
    <img class="headicon" src="https://search3958.github.io/icons/docs.webp" height="71">
<textarea id="editor"></textarea>
<input type="file" id="file-input" accept=".html,.txt" style="display: none;">

<script>
document.addEventListener("DOMContentLoaded", function () {
  if (typeof tinymce === "undefined" || typeof LZString === "undefined") {
    console.error("❌ 必要なライブラリ（TinyMCE または LZString）が読み込まれていません。");
    return;
  }

  tinymce.init({
    selector: "#editor",
    language: 'ja',
    
    // ✨ ドキュメントボタンを先頭に追加
    menubar: "documentlink file edit view format tools", 
    
    toolbar: "undo redo | bold italic underline | alignleft aligncenter alignright | bullist numlist outdent indent | removeformat",
    resize: false,
    branding: false,
    height: "100vh",
    width: "100vw",
    skin: "oxide",
    content_style: `
      /* ✨ エディタ内のフォントを M PLUS 2 に設定 */
      body {
        font-family: 'M PLUS 2', sans-serif;
        font-size: 16px;
        color: #333;
        background-color: #fff;
        height: 100vh;
        overflow-y: auto;
        padding: 20px;
      }
    `,
    plugins: "autolink lists",
    
    // カスタムメニュー項目の設定
    menu: {
      file: { 
        title: 'ファイル', 
        items: 'customnewdocument openfile downloadfile | undo redo' 
      }
    },

    setup: function (editor) {
      
      // --- カスタムメニュー項目の登録 ---

      // ✨ 0. メニューバーに統合する「ドキュメント」ボタン/メニュー項目
      editor.ui.registry.addMenuItem('documentlink', {
          text: 'ドキュメント',
          // ドロップダウンメニューではないため、onActionで直接処理
          onAction: () => {
              // alert('「ドキュメント」メニューがクリックされました。');
              // ここに任意の動作（例: ファイル一覧を開く、トップに戻るなど）を追加できます
          }
      });

      // 1. 新規ドキュメント (確認プロンプト付き)
      editor.ui.registry.addMenuItem('customnewdocument', {
        text: '新規ドキュメント',
        icon: 'new-document',
        onAction: () => {
          const content = editor.getContent();
          // 空白文字、またはTinyMCEのデフォルトの空段落タグであるかを確認
          if (content.trim() !== "" && content !== "<p>&nbsp;</p>") { 
            if (confirm("現在の内容を削除して新規ドキュメントを作成しますか？")) {
              editor.setContent('');
              console.log("✅ 新規ドキュメントを作成しました。");
            }
          } else {
            editor.setContent('');
            console.log("✅ 新規ドキュメントを作成しました。");
          }
        }
      });

      // 2. 開く (ローカルファイル読み込み)
      editor.ui.registry.addMenuItem('openfile', {
        text: '開く...',
        icon: 'folder',
        onAction: () => {
          const content = editor.getContent();
          if (content.trim() !== "" && content !== "<p>&nbsp;</p>") {
             if (!confirm("ファイルを読み込むと内容が上書きされますがよろしいですか？")) {
                return;
             }
          }
          document.getElementById('file-input').click();
        }
      });
      
      // 3. ダウンロード (HTMLファイルとして)
      editor.ui.registry.addMenuItem('downloadfile', {
        text: 'ダウンロード',
        icon: 'save',
        onAction: () => {
          const content = editor.getContent();
          const blob = new Blob([content], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'document_' + new Date().toISOString().slice(0, 10) + '.html';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          console.log("✅ ドキュメントをダウンロードしました。");
        }
      });

      // --- ファイル入力の処理 ---
      document.getElementById('file-input').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
          editor.setContent(e.target.result);
          console.log(`✅ ファイル '${file.name}' を読み込みました。`);
        };
        reader.onerror = function() {
          console.error("❌ ファイルの読み込みに失敗しました。");
          alert("ファイルの読み込みに失敗しました。");
        };
        reader.readAsText(file);
        event.target.value = ''; 
      });

      // --- 自動保存と復元（変更なし） ---
      const saved = localStorage.getItem("tinyMCE_autoSave_compressed");
      if (saved) {
        try {
          const decompressed = LZString.decompress(saved);
          if (decompressed !== null) {
            editor.on("init", () => {
              editor.setContent(decompressed);
              console.log("✅ 保存済みデータを復元しました。");
            });
          }
        } catch (err) {
          console.error("❌ 復元エラー:", err);
        }
      }

      setInterval(() => {
        try {
          const content = editor.getContent();
          const compressed = LZString.compress(content);
          localStorage.setItem("tinyMCE_autoSave_compressed", compressed);
        } catch (e) {
          console.error("❌ 保存エラー:", e);
        }
      }, 3000);
    }
  });
});
</script>
</body>
</html>